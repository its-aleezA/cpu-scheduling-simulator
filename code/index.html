<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Process Scheduler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #0a0a2a;
            color: #00ffcc;
            line-height: 1.6;
            padding: 20px;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 255, 204, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 0, 204, 0.1) 0%, transparent 20%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            border: 4px solid #ff00cc;
            border-radius: 8px;
            padding: 20px;
            background-color: rgba(10, 10, 42, 0.9);
            box-shadow: 0 0 20px rgba(255, 0, 204, 0.5);
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-bottom: 3px dashed #ff00cc;
        }
        
        h1 {
            color: #ffcc00;
            font-size: 2.5rem;
            text-shadow: 3px 3px 0 #ff00cc, 6px 6px 0 #000;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        
        .subtitle {
            color: #00ffcc;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .input-section, .output-section {
            padding: 20px;
            border: 2px solid #00ffcc;
            border-radius: 8px;
            background-color: rgba(0, 20, 40, 0.7);
        }
        
        .output-section {
            display: flex;
            flex-direction: column;
        }
        
        h2 {
            color: #ffcc00;
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 2px 2px 0 #ff00cc;
            border-bottom: 2px dashed #ff00cc;
            padding-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #00ffcc;
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            background-color: #0a0a2a;
            border: 2px solid #ff00cc;
            color: #00ffcc;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #ffcc00;
            box-shadow: 0 0 10px #ffcc00;
        }
        
        .btn {
            background-color: #ff00cc;
            color: #0a0a2a;
            border: none;
            padding: 12px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 5px;
            border: 2px solid transparent;
        }
        
        .btn:hover {
            background-color: #ffcc00;
            color: #0a0a2a;
            border: 2px solid #ff00cc;
            box-shadow: 0 0 15px #ffcc00;
        }
        
        .btn-primary {
            background-color: #ffcc00;
            color: #0a0a2a;
        }
        
        .btn-primary:hover {
            background-color: #ff00cc;
            color: #0a0a2a;
        }
        
        .process-inputs {
            margin-top: 20px;
        }
        
        .process-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background-color: rgba(255, 0, 204, 0.1);
            border: 1px solid #ff00cc;
        }
        
        .process-row label {
            font-size: 0.7rem;
        }
        
        .algorithm-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .algorithm-btn {
            background-color: #0a0a2a;
            border: 2px solid #00ffcc;
            color: #00ffcc;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .algorithm-btn:hover, .algorithm-btn.active {
            background-color: #00ffcc;
            color: #0a0a2a;
            box-shadow: 0 0 10px #00ffcc;
        }
        
        .results {
            margin-top: 20px;
            flex-grow: 1;
            overflow-y: auto;
            max-height: 400px;
        }
        
        .results pre {
            background-color: #0a0a2a;
            padding: 15px;
            border: 2px solid #ff00cc;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .gantt-chart {
            margin-top: 20px;
            padding: 15px;
            background-color: #0a0a2a;
            border: 2px solid #ffcc00;
        }
        
        .gantt-bar {
            display: inline-block;
            height: 40px;
            margin: 5px;
            background-color: #ff00cc;
            color: #0a0a2a;
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            position: relative;
            border: 2px solid #ffcc00;
        }
        
        .gantt-time {
            position: absolute;
            bottom: -20px;
            left: 0;
            font-size: 0.7rem;
            color: #00ffcc;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-box {
            padding: 15px;
            background-color: rgba(0, 255, 204, 0.1);
            border: 2px solid #00ffcc;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            color: #ffcc00;
            margin: 10px 0;
        }
        
        .pixel-border {
            position: relative;
            border: 4px solid #ff00cc;
            border-image: 
                repeating-linear-gradient(
                    45deg,
                    #ff00cc,
                    #ff00cc 10px,
                    #0a0a2a 10px,
                    #0a0a2a 20px
                ) 10;
        }
        
        .pixel-corner {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #ff00cc;
        }
        
        .pixel-corner.tl {
            top: -2px;
            left: -2px;
        }
        
        .pixel-corner.tr {
            top: -2px;
            right: -2px;
        }
        
        .pixel-corner.bl {
            bottom: -2px;
            left: -2px;
        }
        
        .pixel-corner.br {
            bottom: -2px;
            right: -2px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            border-top: 3px dashed #ff00cc;
            color: #00ffcc;
            font-size: 0.8rem;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .algorithm-selector {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container pixel-border">
        <div class="pixel-corner tl"></div>
        <div class="pixel-corner tr"></div>
        <div class="pixel-corner bl"></div>
        <div class="pixel-corner br"></div>
        
        <header>
            <h1>ARCADE PROCESS SCHEDULER</h1>
            <p class="subtitle">90s Retro Style CPU Scheduling Simulator</p>
        </header>
        
        <div class="main-content">
            <div class="input-section">
                <h2>PROCESS SETUP</h2>
                
                <div class="form-group">
                    <label for="processCount">NUMBER OF PROCESSES:</label>
                    <input type="number" id="processCount" min="1" max="10" value="3">
                    <button class="btn" id="generateProcesses">GENERATE PROCESSES</button>
                </div>
                
                <div class="process-inputs" id="processInputs">
                    <!-- Process inputs will be generated here -->
                </div>
                
                <h2>SCHEDULING ALGORITHM</h2>
                
                <div class="algorithm-selector">
                    <div class="algorithm-btn active" data-algo="1">FCFS</div>
                    <div class="algorithm-btn" data-algo="2">SJF (Non-Preemptive)</div>
                    <div class="algorithm-btn" data-algo="3">SJF (Preemptive)</div>
                    <div class="algorithm-btn" data-algo="4">Priority (Non-Preemptive)</div>
                    <div class="algorithm-btn" data-algo="5">Priority (Preemptive)</div>
                </div>
                
                <button class="btn btn-primary" id="runScheduler">RUN SCHEDULER</button>
                <button class="btn" id="resetBtn">RESET</button>
            </div>
            
            <div class="output-section">
                <h2>SCHEDULING RESULTS</h2>
                
                <div class="results">
                    <pre id="outputConsole">Welcome to the Arcade Process Scheduler!
Set up your processes and select an algorithm to begin.</pre>
                </div>
                
                <div class="gantt-chart" id="ganttChart">
                    <h3>GANTT CHART</h3>
                    <div id="ganttContainer">
                        <!-- Gantt chart will be displayed here -->
                    </div>
                </div>
                
                <div class="metrics">
                    <div class="metric-box">
                        <div>AVERAGE WAITING TIME</div>
                        <div class="metric-value" id="avgWaitTime">0.00</div>
                    </div>
                    <div class="metric-box">
                        <div>THROUGHPUT</div>
                        <div class="metric-value" id="throughput">0.00</div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>ARCADE PROCESS SCHEDULER © 2023 | RETRO STYLE CPU SCHEDULING SIMULATOR</p>
        </footer>
    </div>

    <script>
        // Process data structure
        class Process {
            constructor(processID, arrivalTime, burstTime, priority = 0) {
                this.processID = processID;
                this.arrivalTime = arrivalTime;
                this.burstTime = burstTime;
                this.priority = priority;
                this.remainingTime = burstTime;
                this.completionTime = 0;
                this.waitingTime = 0;
                this.turnaroundTime = 0;
                this.isCompleted = false;
            }
        }

        // Base scheduler class
        class SchedulerBase {
            constructor(processes) {
                this.processes = processes;
                this.n = processes.length;
                this.ganttStart = [];
                this.ganttPid = [];
            }

            run() {
                // To be implemented by specific schedulers
            }

            calculateMetrics() {
                let totalWait = 0;
                let totalTurnaround = 0;
                let maxCompletion = 0;

                for (const p of this.processes) {
                    totalWait += p.waitingTime;
                    totalTurnaround += p.turnaroundTime;
                    if (p.completionTime > maxCompletion) {
                        maxCompletion = p.completionTime;
                    }
                }

                const avgWait = totalWait / this.n;
                const avgTurnaround = totalTurnaround / this.n;
                const throughput = this.n / maxCompletion;

                return {
                    avgWait: avgWait.toFixed(2),
                    avgTurnaround: avgTurnaround.toFixed(2),
                    throughput: throughput.toFixed(2)
                };
            }

            printTable() {
                let table = "PROCESS EXECUTION TABLE:\n";
                table += "PID     Arrival  Burst   Priority  Completion  Turnaround  Waiting\n";
                
                for (const p of this.processes) {
                    table += `P${p.processID}      ${p.arrivalTime}       ${p.burstTime}       ${p.priority}         ${p.completionTime}           ${p.turnaroundTime}           ${p.waitingTime}\n`;
                }
                
                return table;
            }

            generateGanttChart() {
                let html = '';
                for (let i = 0; i < this.ganttPid.length; i++) {
                    const width = (i + 1 < this.ganttStart.length ? 
                                  this.ganttStart[i + 1] - this.ganttStart[i] : 
                                  this.getMaxCompletion() - this.ganttStart[i]) * 30;
                    
                    html += `<div class="gantt-bar" style="width: ${width}px;">
                                P${this.ganttPid[i]}
                                <div class="gantt-time">${this.ganttStart[i]}</div>
                            </div>`;
                    
                    if (i === this.ganttPid.length - 1) {
                        html += `<div class="gantt-time" style="left: ${width}px;">${this.getMaxCompletion()}</div>`;
                    }
                }
                return html;
            }

            getMaxCompletion() {
                let maxCT = 0;
                for (const p of this.processes) {
                    if (p.completionTime > maxCT) {
                        maxCT = p.completionTime;
                    }
                }
                return maxCT;
            }
        }

        // Specific scheduler implementations
        class FCFS extends SchedulerBase {
            run() {
                // Sort by arrival time
                this.processes.sort((a, b) => a.arrivalTime - b.arrivalTime);
                
                let currentTime = 0;
                for (const p of this.processes) {
                    currentTime = Math.max(currentTime, p.arrivalTime);
                    this.ganttStart.push(currentTime);
                    this.ganttPid.push(p.processID);
                    
                    currentTime += p.burstTime;
                    p.completionTime = currentTime;
                    p.turnaroundTime = p.completionTime - p.arrivalTime;
                    p.waitingTime = p.turnaroundTime - p.burstTime;
                }
            }
        }

        class SJF extends SchedulerBase {
            run() {
                let currentTime = 0;
                let completed = 0;
                
                while (completed < this.n) {
                    let idx = -1;
                    let minBT = Number.MAX_SAFE_INTEGER;
                    
                    for (let i = 0; i < this.n; i++) {
                        const p = this.processes[i];
                        if (!p.isCompleted && p.arrivalTime <= currentTime && p.burstTime < minBT) {
                            minBT = p.burstTime;
                            idx = i;
                        }
                    }
                    
                    if (idx === -1) {
                        currentTime++;
                        continue;
                    }
                    
                    const p = this.processes[idx];
                    this.ganttStart.push(currentTime);
                    this.ganttPid.push(p.processID);
                    
                    currentTime += p.burstTime;
                    p.completionTime = currentTime;
                    p.turnaroundTime = p.completionTime - p.arrivalTime;
                    p.waitingTime = p.turnaroundTime - p.burstTime;
                    p.isCompleted = true;
                    completed++;
                }
            }
        }

        class PreemptiveSJF extends SchedulerBase {
            run() {
                let currentTime = 0;
                let completed = 0;
                let lastPid = -1;
                
                // Initialize remaining times
                for (const p of this.processes) {
                    p.remainingTime = p.burstTime;
                }
                
                while (completed < this.n) {
                    let idx = -1;
                    let minRT = Number.MAX_SAFE_INTEGER;
                    
                    for (let i = 0; i < this.n; i++) {
                        const p = this.processes[i];
                        if (!p.isCompleted && p.arrivalTime <= currentTime && 
                            p.remainingTime < minRT && p.remainingTime > 0) {
                            minRT = p.remainingTime;
                            idx = i;
                        }
                    }
                    
                    if (idx === -1) {
                        currentTime++;
                        lastPid = -1;
                        continue;
                    }
                    
                    const p = this.processes[idx];
                    if (lastPid !== p.processID) {
                        this.ganttStart.push(currentTime);
                        this.ganttPid.push(p.processID);
                        lastPid = p.processID;
                    }
                    
                    p.remainingTime--;
                    currentTime++;
                    
                    if (p.remainingTime === 0) {
                        p.completionTime = currentTime;
                        p.turnaroundTime = p.completionTime - p.arrivalTime;
                        p.waitingTime = p.turnaroundTime - p.burstTime;
                        p.isCompleted = true;
                        completed++;
                    }
                }
            }
        }

        class PriorityNonPreemptive extends SchedulerBase {
            run() {
                let currentTime = 0;
                let completed = 0;
                
                while (completed < this.n) {
                    let idx = -1;
                    let highestPriority = Number.MAX_SAFE_INTEGER;
                    
                    for (let i = 0; i < this.n; i++) {
                        const p = this.processes[i];
                        if (!p.isCompleted && p.arrivalTime <= currentTime && 
                            p.priority < highestPriority) {
                            highestPriority = p.priority;
                            idx = i;
                        }
                    }
                    
                    if (idx === -1) {
                        currentTime++;
                        continue;
                    }
                    
                    const p = this.processes[idx];
                    this.ganttStart.push(currentTime);
                    this.ganttPid.push(p.processID);
                    
                    currentTime += p.burstTime;
                    p.completionTime = currentTime;
                    p.turnaroundTime = p.completionTime - p.arrivalTime;
                    p.waitingTime = p.turnaroundTime - p.burstTime;
                    p.isCompleted = true;
                    completed++;
                }
            }
        }

        class PriorityPreemptive extends SchedulerBase {
            run() {
                let currentTime = 0;
                let completed = 0;
                let lastPid = -1;
                
                // Initialize remaining times
                for (const p of this.processes) {
                    p.remainingTime = p.burstTime;
                }
                
                while (completed < this.n) {
                    let idx = -1;
                    let highestPriority = Number.MAX_SAFE_INTEGER;
                    
                    for (let i = 0; i < this.n; i++) {
                        const p = this.processes[i];
                        if (!p.isCompleted && p.arrivalTime <= currentTime && 
                            p.remainingTime > 0 && p.priority < highestPriority) {
                            highestPriority = p.priority;
                            idx = i;
                        }
                    }
                    
                    if (idx === -1) {
                        currentTime++;
                        lastPid = -1;
                        continue;
                    }
                    
                    const p = this.processes[idx];
                    if (lastPid !== p.processID) {
                        this.ganttStart.push(currentTime);
                        this.ganttPid.push(p.processID);
                        lastPid = p.processID;
                    }
                    
                    p.remainingTime--;
                    currentTime++;
                    
                    if (p.remainingTime === 0) {
                        p.completionTime = currentTime;
                        p.turnaroundTime = p.completionTime - p.arrivalTime;
                        p.waitingTime = p.turnaroundTime - p.burstTime;
                        p.isCompleted = true;
                        completed++;
                    }
                }
            }
        }

        // UI Logic
        document.addEventListener('DOMContentLoaded', function() {
            const processCountInput = document.getElementById('processCount');
            const generateProcessesBtn = document.getElementById('generateProcesses');
            const processInputsContainer = document.getElementById('processInputs');
            const algorithmButtons = document.querySelectorAll('.algorithm-btn');
            const runSchedulerBtn = document.getElementById('runScheduler');
            const resetBtn = document.getElementById('resetBtn');
            const outputConsole = document.getElementById('outputConsole');
            const ganttContainer = document.getElementById('ganttContainer');
            const avgWaitTimeEl = document.getElementById('avgWaitTime');
            const throughputEl = document.getElementById('throughput');
            
            let selectedAlgorithm = 1; // Default to FCFS
            let processes = [];
            
            // Initialize with default processes
            generateProcessInputs();
            
            // Event listeners
            generateProcessesBtn.addEventListener('click', generateProcessInputs);
            
            algorithmButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    algorithmButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    selectedAlgorithm = parseInt(this.getAttribute('data-algo'));
                    
                    // Show/hide priority inputs based on algorithm
                    const priorityInputs = document.querySelectorAll('.priority-input');
                    const shouldShowPriority = selectedAlgorithm === 4 || selectedAlgorithm === 5;
                    
                    priorityInputs.forEach(input => {
                        input.style.display = shouldShowPriority ? 'block' : 'none';
                    });
                });
            });
            
            runSchedulerBtn.addEventListener('click', runScheduler);
            resetBtn.addEventListener('click', resetScheduler);
            
            function generateProcessInputs() {
                const count = parseInt(processCountInput.value);
                processInputsContainer.innerHTML = '';
                
                for (let i = 0; i < count; i++) {
                    const processRow = document.createElement('div');
                    processRow.className = 'process-row';
                    
                    processRow.innerHTML = `
                        <div>
                            <label for="arrival${i}">Arrival Time:</label>
                            <input type="number" id="arrival${i}" min="0" value="${i}">
                        </div>
                        <div>
                            <label for="burst${i}">Burst Time:</label>
                            <input type="number" id="burst${i}" min="1" value="${Math.floor(Math.random() * 10) + 1}">
                        </div>
                        <div class="priority-input" style="display: ${selectedAlgorithm === 4 || selectedAlgorithm === 5 ? 'block' : 'none'}">
                            <label for="priority${i}">Priority:</label>
                            <input type="number" id="priority${i}" min="1" value="${Math.floor(Math.random() * 5) + 1}">
                        </div>
                    `;
                    
                    processInputsContainer.appendChild(processRow);
                }
            }
            
            function runScheduler() {
                // Get process data from inputs
                processes = [];
                const count = parseInt(processCountInput.value);
                
                for (let i = 0; i < count; i++) {
                    const arrival = parseInt(document.getElementById(`arrival${i}`).value);
                    const burst = parseInt(document.getElementById(`burst${i}`).value);
                    let priority = 0;
                    
                    if (selectedAlgorithm === 4 || selectedAlgorithm === 5) {
                        priority = parseInt(document.getElementById(`priority${i}`).value);
                    }
                    
                    processes.push(new Process(i+1, arrival, burst, priority));
                }
                
                // Create appropriate scheduler
                let scheduler;
                switch(selectedAlgorithm) {
                    case 1: scheduler = new FCFS(processes); break;
                    case 2: scheduler = new SJF(processes); break;
                    case 3: scheduler = new PreemptiveSJF(processes); break;
                    case 4: scheduler = new PriorityNonPreemptive(processes); break;
                    case 5: scheduler = new PriorityPreemptive(processes); break;
                    default: scheduler = new FCFS(processes);
                }
                
                // Run the scheduler
                scheduler.run();
                
                // Display results
                const metrics = scheduler.calculateMetrics();
                outputConsole.textContent = scheduler.printTable();
                ganttContainer.innerHTML = scheduler.generateGanttChart();
                avgWaitTimeEl.textContent = metrics.avgWait;
                throughputEl.textContent = metrics.throughput;
                
                // Add algorithm name to output
                const algoNames = [
                    '', 'FCFS', 'SJF (Non-Preemptive)', 'SJF (Preemptive)', 
                    'Priority (Non-Preemptive)', 'Priority (Preemptive)'
                ];
                
                outputConsole.textContent = `ALGORITHM: ${algoNames[selectedAlgorithm]}\n\n` + outputConsole.textContent;
            }
            
            function resetScheduler() {
                processCountInput.value = 3;
                generateProcessInputs();
                outputConsole.textContent = 'Welcome to the Arcade Process Scheduler!\nSet up your processes and select an algorithm to begin.';
                ganttContainer.innerHTML = '';
                avgWaitTimeEl.textContent = '0.00';
                throughputEl.textContent = '0.00';
            }
        });
    </script>
</body>
</html>
